'''
• < 다이나믹 프로그래밍 > (동적 계획법)
  • 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
  • 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함
  • 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(탑다운/하향식과 보텀업/상향식)으로 구현됨
 
  • 일반적으로, '동적' = 프로그램이 실행되는 도중에 ~ 의미
  • ex ) 동적 할당 = 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 방법
  • 반면, 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어
  
• 다이나믹 프로그래밍의 조건 : 
  • 최적 부분 구조 (optimal substructure)
    • 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있음
  • 중복되는 부분 문제 (overlapping subproblem)
    • 동일한 작은 문제를 반복적으로 해결해야 함
    
• 하향식(탑다운) 다이나믹 프로그래밍 / 발산구조 : 메모이제이션 (Memoization) 사용 
  • 다이나믹 프로그래밍을 구현하는 방법 중 하나
  • 한 번 계산한 결과를 메모리 공간에 메모하는 기법
  • 이전에 계산한 결과를 일시적으로 기록해 놓는 넓은 개념 -> 다이나믹 프로그래밍에 국한된 개념은 X
  • 한 번 계산된 결과를 담아놓기만 하고, 다이나믹 프로그래밍을 위해 활용하지 않을수도 있음
  • 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
  • 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 함
  
  • 재귀함수를 주로 이용 (작은 문제들을 재귀적으로 호출 -> 모두 해결 후 큰 문제에 대한 답을 얻을 수 있음)
  
• 상향식(보텀업) 다이나믹 프로그래밍 / 수렴구조 : 전형적인 형태
  • 결과 저장용 리스트 = DP 테이블 --> 인덱스 값 = '실제' ~ 번째 수로 인식 <-> 내가 필요한 수 +1 까지 인덱스를 생성
  • 아래쪽에서부터 작은 문제를 하나씩 해결 -> 다음의 문제까지 차례대로 해결
  
  • 반복문을 주로 이용 
  
    
    
• 피보나치 수열 : 다이나믹 프로그래밍으로 효과적으로 계산가능함
• 점화식 : 인접한 항들 사이의 관계식
  • 피보나치 수열을 점화식으로 표현하면 다음과 같음 : a_n = a_n-1 + a_n-2 (a1 = 1, a2 = 1)
  • 재귀함수로 피보나치 수여를 구현하면 : 지수 시간 복잡도 -> 발산 재귀함수 구조 (동일한 함수가 여러번 호출됨)
  • 시간 복잡도  = 세타 표기법 theta(1.618...^N), 빅오 표기법 O(2^N) --> f(30)을 계산하기 위해 약 10억번 연산필요

'''

def fibo(x) : 
    if x ==1 or x==2 : 
        return 1
    else : 
        return fibo(x-2) + fibo(x-1)
    
print(fibo(35))

# 한 번 계산된 결과를 메모이제이션하기 위해 리스트 초기화
array = [0] * 101 # 100번까지 하려면 +1의 과정이 필요

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍) : O(N)
def fibo_new(x) : 
    # 종료 조건 (1 혹은 2일 때 1을 반환)
    if x ==1 or x==2 : 
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if array[x]!=0 : 
        return array[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    array[x] = fibo_new(x-1) + fibo_new(x-2)
    return array[x]

print(fibo_new(35))

# 피보나치 함수를 반복문으로 구현 (보텀업 다이나믹 프로그래밍)

# 앞서 계산된 결과를 저장하기 위해 DP 테이블 초기화
array = [0] * 101

# 첫번째 피보나치 수와 두 번째 피보나치 수는 1
array[1] = 1
array[2] = 1
n = 100

# 피보나치 함수 반복문으로 구현 (보텀업 다이나믹 프로그래밍)
for i in range(3,n+1) : 
    array[i] = array[i-1] + array[i-2]
print(array[n])



